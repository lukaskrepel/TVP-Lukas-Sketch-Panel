PARAM none
tv_GetProjectName
projectpath = result
tv_WriteTextFile "Exists" '"'projectpath'"'
testPath = result
IF CMP(testPath,projectpath)==0 || CMP(projectpath,"\")==1
	tv_warn "PLEASE SAVE TVP PROJECT TO EXPORT CLIP TO ADOBE AFTER EFFECTS"
ELSE
	tv_version 
	PARSE result name number language
	NewParse(number,".")
	tvpVersion = var(1)
	tv_saveMode "PNG"
	ext = ".png"
	tv_AlphaSaveMode "NoPreMultiply"
	tv_Background "NONE"
	startBG = result
	
	PARSE startBG type R G B rest
	IF CMP(type,"none")==1
		R=0
		G=0
		B=0
	END
	R = R/255
	G = G/255
	B = B/255
	bgString = R","G","B
	
	tv_LayerCurrentID
	startLayer = result
	tv_layerGetImage
	startImage = result
	
	// MAKING THE SCRIPT WORK ON WINDOWS AND MAC , Windows has directory seperated by \ and mac and linux with /
	projectpath = Replace(projectpath,'\','/')
	strlen = LEN(projectpath)
	last = LastPos(projectpath,"/")
	// Getting the directory where the TVPP file is saved
	projectdir = LeftString(projectpath,last-1)
	// getting the name of the tvpp file without the path
	projectname = RightString(projectpath,strlen-last)
	// getting the name of the tvpp file without ".tvpp"
	strlen = LEN(projectname)
	last = LastPos(projectname,".")
	IF CMP(last,"0")==1
		projectbase = projectname
	ELSE
		projectbase = LeftString(projectname,last-1)
	END
	// Create the projectDir
	parentDir = projectdir"/"projectbase
	tv_WriteTextFile "MkDir" '"'parentDir'"'
	
	tv_clipName 0
	clipName = result
	clipDir = parentDir"/"clipName
	//tv_WriteTextFile "Remove" '"'clipDir'"'
	tv_WriteTextFile "MkDir" '"'clipDir'"'
	
	// Here I get the in point and out point of the clip if the maeks is disabled I get the clip in out instead
	//get clip in
	tv_markIn clip
	PARSE result frame state
	IF CMP(state,"set ")==1
		inpoint = frame
	ELSE
		//tv_firstImage
		inpoint = 0
	END
	//Get Clip Out
	tv_markOut clip
	PARSE result frame state
	IF CMP(state,"set ")==1
		outpoint = frame
	ELSE
		tv_LastImage
		outpoint = result
	END
	
	duration = outpoint-inpoint+1
	
	//WRITE CLIPINF0
	tv_frameRate 666 info
	PARSE result projectFramerate previewFramerate
	tv_frameRate projectFramerate
	clipInfo = clipDir"/clipinfo.txt"
	// First I remove it or delete it so old files will be deleted!!
	tv_WriteTextFile "Remove" '"'clipInfo'"'
	tv_WriteTextFile "Create" '"'clipInfo'"' "framerate;"projectFramerate
	tv_WriteTextFile "Append" '"'clipInfo'"' "duration;"duration
	tv_WriteTextFile "Append" '"'clipInfo'"' "bgcolor;"bgString
	
	
	
	// CREATE ARRAY WITH VISIBLE LAYERS
	loop= 1
	i= 0
	WHILE loop
		tv_LayerGetID i
		curLID= result	
		IF CMP(curLID,"NONE")==0		
			
			// START RUN ON LAYER 
		       tv_LayerDisplay curLID "OFF"
		       layerDisplay(i) = result
			// END RUN ON LAYER
			i= i+1	
		ELSE		
			loop=0
		END
	END
	layerNUM = i-1
	
	//save Layer
	lele=1
	tv_ResetDisplay
	tv_lockDisplay "Export Layers"
	FOR i=0 TO layerNUM
		display = layerDisplay(i)
		IF CMP(display,"On")==1
			tv_LayerGetID i
			curId = result
			tv_layerSet curId
			tv_UpdateUndo
			tv_LayerDisplay curId "On"
			tv_layerSet curId
			tv_LayerInfo 0
			PARSE result layerDisplay layerPosition layerOpacity mylayerName layerType layerStart layerEnd layerPrelighttable layerPostlighttable layerSelection
			tv_LayerDisplay curId "Off"
			tv_LayerDisplay curId "On"
			tv_UnLockDisplay
			tv_ResetDisplay
			tv_lockDisplay "Export Layer:"mylayerName
			lepos=i+1
			layer_save(clipDir,lepos,inpoint,outpoint)
			tv_LayerDisplay curId "Off"
			lele=lele+1
		END
	END
	tv_UnLockDisplay
	
	
	// reset Display
	FOR i=0 TO layerNUM
		display = layerDisplay(i)
		tv_LayerGetID i
		tv_LayerDisplay result display
	END
	
	
	tv_layerSet startLayer
	tv_layerImage startImage
	tv_Background startBG
	
END



//{{{ layer_save(clipDir,layerPos,inpoint,outpoint)
function layer_save(clipDir,layerPos,inpoint,outpoint)
	LOCAL  layerDisplay layerPosition layerOpacity layerName layerType layerStart layerEnd layerPrelighttable layerPostlighttable layerSelection prefix opac
	tv_LayerInfo
	PARSE result layerDisplay layerPosition layerOpacity layerName layerType layerStart layerEnd layerPrelighttable layerPostlighttable layerSelection
	
	tv_LayerCurrentID
	curLID = result
	tv_layerGetImage
	startImage = result
	
	prefix = addZeros("L",layerPos,2)
	prefix=prefix"_"layerName
	
	holdPre=0
	IF layerStart < inpoint
		renderStart = inpoint
	ELSE
		IF layerStart > inpoint
			IF tvpVersion < 10
				renderStart = layerStart
			ELSE
				tv_layerprebehavior curLID
				pre = result
				IF CMP(pre,"none")==0
					renderStart = inpoint
					holdPre=1
				ELSE
					renderStart = layerStart
				END
			END
		ELSE
		
			renderStart = layerStart
		END
	END
	
	IF layerEnd > outpoint
		renderEnd = outpoint
	ELSE
		IF layerEnd < outpoint
			IF tvpVersion < 10
				renderEnd = layerEnd
			ELSE
				tv_layerpostbehavior  0
				post = result
				IF CMP(post,"none")==0 
					renderEnd = outpoint
				ELSE
					renderEnd = layerEnd
				END
			END
		ELSE
			renderEnd = layerEnd
		END
	END
	delta=outpoint-inpoint+1
	numnum = LEN(delta)
	offsetSTART= renderStart-inpoint+1
	offsetEND = renderEnd-inpoint+1
	
	
	saveDir = clipDir"/"prefix
	
	tv_WriteTextFile "Remove" '"'saveDir'"'
	tv_WriteTextFile "MkDir" '"'saveDir'"'
	
	// write Layer Info
	layerInfo = saveDir"/layerinfo.txt"
	tv_WriteTextFile "Create" '"'layerInfo'"' "IN;"offsetSTART
	tv_WriteTextFile "Append" '"'layerInfo'"' "OUT;"offsetEND
	
	tv_layerblendingmode 0 "COLOR"
	blendmode = result
	tv_WriteTextFile "Append" '"'layerInfo'"' "Blendingmode;"blendmode
	
	tv_LayerDensity 100
	density=result
	tv_WriteTextFile "Append" '"'layerInfo'"' "Opacity;"density
	
	tv_layercolor "get" curLID
	color = result
	length = LEN(color)
	IF CMP(length,"6")==1
		color = CUT(color,1,1)
	END
	IF CMP(length,"7")==1
		color = CUT(color,1,2)
	END
	
	tv_WriteTextFile "Append" '"'layerInfo'"' "Label;"color
	
	
	tv_UpdateUndo
	// create RENDER layer
	tv_LayerCreate "render"
	renderLID = result
	tv_layerSet renderLID
	tv_LayerAnim
	tv_LayerShift renderLID renderStart
	tv_exposureadd renderStart renderEnd-renderStart
	tv_LayerMerge curLID 
	tv_LayerDisplay curLID "Off"
	curImage = renderStart
	WHILE curImage<=renderEnd
		tv_layerImage curImage
		offsetImage= curImage-inpoint+1
		leNumber = addZeros("_",offsetImage,numnum)
		imageName = saveDir'/'prefix''leNumber'.png'
		tv_saveDisplay imageName
		tv_exposureNext
		curImage=result
		tv_exposureinfo curImage
		PARSE result type rest
		IF CMP(type,"Head")==0
			curImage=renderEnd+1
		END
	END
	
	tv_LayerKill renderLID
	tv_LayerSet curLID
	tv_LayerDisplay curLID "On"
	tv_layerblendingmode 0 blendmode
	tv_LayerDensity density
	tv_layerImage startImage
END
//}}}

//{{{ addZeros(prefix,digit,length)
FUNCTION addZeros(moprefix,modigit,molength)
	LOCAL mocur moi
	molength=molength*1
	modigit=modigit*1
	mocur = LEN(modigit)
	molength=molength-1
	FOR moi=mocur TO molength
		moprefix=moprefix"0"
	END
	moprefix =moprefix""modigit
	myResult = moprefix
	result = moprefix
	RETURN myResult
END

//}}}

//{{{** BASIC FUNCTIONS

//{{{ Find
//------------------------------------------
//
//	Find
//
//	Function: find a character into a string
//            from a specified start position
//
//	Call: Find(string,car,start)
//
//	Arguments:
//		string = characters string
//		car    = character to look for
//		start  = start position in string
//
//	Return: position of character
//			0 if character does not exist
//			into string
//			-1 if invalid position
//			(negative, null or higher
//			 than string length)
//
//------------------------------------------

FUNCTION Find(string,car,start)
	LOCAL i size
	i = start
	size = LEN(string)
	
	IF ((start <= 0) || (start > size) || (CMP(car,"") == 1))
		RETURN -1
	END
	DO
		IF (CMP(CHAR(string,i),car) == 1)
			RETURN i
		END
	UNTIL ((i=i+1) > size)
	RETURN 0
END
//}}}

//{{{ FirstPos(string,car)
//------------------------------------------
//
//	FirstPos
//
//	Function: find first occurence of a
//			  character into a string
//
//	Call: FirstPos(string,car)
//
//	Arguments:
//		string = characters string
//		car    = character to look for
//
//	Return: position of character
//			or 0 id character does not
//			exist into string.
//
//------------------------------------------

FUNCTION FirstPos(string,car)
	RETURN Find(string,car,1)
END
//}}}

//{{{  LastPos(string,car)
//------------------------------------------
//
//	LastPos
//
//	Function: find last occurence of a
//			  character into a string
//
//	Call: LastPos(string,car)
//
//	Arguments:
//		string = characters string
//		car    = character to look for
//
//	Return: position of character
//			or 0 if character does not
//			exist into string.
//
//------------------------------------------

FUNCTION LastPos(string,car)
	LOCAL loop  myChar 
	pos = LEN(string)
	loop = 1
	WHILE loop
		myChar = CHAR(string,pos)
		
		IF CMP(myChar,car) == 1
			loop =0
		ELSE
			pos = pos-1
		END
		IF pos<1
			loop=0
		END
	END
	RETURN pos
END
//}}}

//{{{ FindString(string,search,start)
//------------------------------------------
//
//	FindString
//
//	Function: find a substring into a string
//             from a specified start position
//
//	Call: FindString(string,search,start)
//
//	Arguments:
//		string = characters string
//		search = substring to look for
//		start  = start position in string
//
//	Return: start position of substring
//			0 if substring does not exist
//			into string
//			-1 if invalid start position
//			(negative, null or higher
//			than string length) or if
//          substring is empty
//
//------------------------------------------

FUNCTION FindString(string,search,start)
	LOCAL found j pos lastpos lstr lsrch
	found = 0
	lastpos = start
	lstr = LEN(string)
	lsrch = LEN(search)
	
	IF (CMP(search,"") == 1)
		RETURN -1
	END
	WHILE ((pos = Find(string,CHAR(search,1),lastpos)) > 0)
		j = 1
		found = 1
		IF (j == lsrch)
			RETURN pos
		END
		WHILE ((j < lsrch) && (found == 1))
			IF ((pos+j) > lstr)
				RETURN 0
			ELSE
				IF (CMP(CHAR(search,j+1),CHAR(string,pos+j)) == 0)
					lastpos = pos+j
					found = 0
				END
			END
			j = j+1
		END
		IF (found == 1)
			RETURN pos
		END
	END
	RETURN pos
END
//}}}

//{{{ LeftString(string,number)
//------------------------------------------
//
//	LeftString
//
//	Function: extract a substring beginning
//            at the start of a string
//			   
//	Call: LeftString(string,number)
//
//	Arguments:
//		string  = characters string
//		number  = number of character to
//			      extract from string
//
//	Return: result substring
//			or 0 if number is negative
//          or null.
//
//------------------------------------------

FUNCTION LeftString(string,number)
	LOCAL size
	size = LEN(string)
	
	IF (number > 0)
		IF (number > size)
			number = size
		END
		RETURN CUT(string,1,number)
	END
	RETURN 0
END
//}}}

//{{{ RightString(string,number)
//------------------------------------------
//
//	RightString
//
//	Function: extract a substring ending
//            at the end of a string
//
//	Call: RightString(string,number)
//
//	Arguments:
//		string  = characters string
//		number  = number of character to
//			      extract from string
//
//	Return: result substring
//			or 0 if number is negative
//          or null.
//
//------------------------------------------

FUNCTION RightString(string,number)
	LOCAL size
	size = LEN(string)
	
	IF (number > 0)
		IF (number > size)
			number = size
		END
		RETURN CUT(string,size-number+1,size)
	END
	RETURN 0
END
//}}}

//{{{ MidString(string,first,size)
//------------------------------------------
//
//	MidString
//
//	Function: extract a substring from a
//			  string
//
//	Call: MidString(string,first,size)
//
//	Arguments:
//		string  = characters string
//		first   = start position in string
//				  chaï¿½ne
//		size    = number of characters
//
//	Return: result substring
//			or 0 if number or first are
//          negatives or null.
//
//------------------------------------------

FUNCTION MidString(string,first,size)
	LOCAL ln
	ln = LEN(string)
	
	IF ((first > 0) && (size > 0))
		IF ((first+size-1) > ln)
			size = ln-first+1
		END
		RETURN CUT(string,first,first+size-1)
	END
	RETURN 0
END
//}}}

//{{{ InsertAtPos(string,insert,pos)
//------------------------------------------
//
//	InsertAtPos
//
//	Function: insert a string in another
//            string at a specified position
//
//	Call: InsertAtPos(string,insert,pos)
//
//	Arguments:
//		string  = characters string 
//		insert  = string to insert
//		pos     = start position for insertion
//
//	Return: result string after insertion
//			or 0 if start position is
//			invalid (negative, null or
//			higher than string length)
//
//------------------------------------------

FUNCTION InsertAtPos(string,insert,pos)
	LOCAL workstr str1 size
	size = LEN(string)

	IF ((pos < 0) || (pos > size))
		RETURN 0
	END
	IF (pos == 0)
		RETURN insert""string
	END
	IF (pos == size)
		RETURN string""insert
	END
	workstr = CUT(string,1,pos)
	IF (pos < size)
		str1 = CUT(string,pos+1,size)
		RETURN workstr""insert""str1
	ELSE
		RETURN workstr""insert
	END
END
//}}}

//}}}**

//{{{** ADVANCED STRING FUNCTIONS

//{{{ InsertAfter(string,insert,search)
//------------------------------------------
//
//	InsertAfter
//
//	Function: insert a string after each
//			  occurence of a character or
//            a set of characters into
//            another string
//
//	Call: InsertAfter(string,insert,search)
//
//	Arguments:
//		string  = characters string
//		insert  = string to insert
//		search  = character or substring
//                to look for
//
//	Return: result string after insertion
//
//------------------------------------------

FUNCTION InsertAfter(string,insert,search)
	LOCAL pos workstr size
	pos = 1
	workstr = string
	size = LEN(search)
	
	WHILE ((pos = FindString(workstr,search,pos)) > 0)
		workstr = InsertStringAtPos(workstr,insert,pos+size-1)
		pos = pos+size+LEN(insert)
	END
	RETURN workstr
END
//}}}

//{{{ InsertBefore
//------------------------------------------
//
//	InsertBefore
//
//	Function: insert a string before each
//			  occurence of a character or
//            a set of characters into
//            another string
//
//	Call: InsertBefore(string,insert,search)
//
//	Arguments:
//		string  = characters string
//		insert  = string to insert
//		search  = character or substring
//                to look for
//
//	Return: result string after insertion
//
//------------------------------------------

FUNCTION InsertBefore(string,insert,search)
	LOCAL pos workstr
	pos = 1
	workstr = string
	
	WHILE ((pos = FindString(workstr,search,pos)) > 0)
		workstr = InsertStringAtPos(workstr,insert,pos-1)
		pos = pos+LEN(search)+LEN(insert)
	END
	RETURN workstr
END
//}}}

//{{{ Delete
//------------------------------------------
//
//	Delete
//
//	Function: delete all occurences of a
//            substring into a string
//
//	Call: Delete(string,search)
//
//	Arguments:
//		string  = characters string
//		search  = substring to delete
//
//	Return: result string after deletion
//
//------------------------------------------

FUNCTION Delete(string,search)
	LOCAL workstr str1 str2 pos size
	workstr = string
	pos = 1
	size = LEN(search)
	
	WHILE ((pos = FindString(workstr,search,1)) > 0)
		IF ((pos != 1) && ((pos+size) < LEN(workstr)))
			str1 = CUT(workstr,1,pos-1)
			str2 = CUT(workstr,pos+size,LEN(workstr))
			workstr = str1""str2
		ELSE
			IF (pos == 1)
				IF ((size+1) < LEN(workstr))
					workstr = CUT(workstr,size+1,LEN(workstr))
				ELSE
					workstr = ""
				END
			ELSE
				workstr = CUT(workstr,1,pos-1)
			END
		END
	END
	RETURN workstr
END
//}}}

//{{{ Replace
//------------------------------------------
//
//	Replace
//
//	Function: replace each occurence of a
//            substring into a string with
//            another string
//
//	Call: Replace(string,search,repl)
//
//	Arguments:
//		string  = characters string
//		search  = substring to look for
//		repl    = replacement substring
//
//	Return: result string after replacement
//
//------------------------------------------

FUNCTION Replace(string,search,repl)
	LOCAL pos workstr str1 str2 size
	pos = 1
	workstr = string
	size = LEN(search)
	
	WHILE ((pos = FindString(workstr,search,pos)) > 0)
		IF (pos == 1)
			str1 = CUT(workstr,size+1,LEN(workstr))
			workstr = repl""str1
			pos = 0
		ELSE
			str1 = CUT(workstr,1,pos-1)
			IF ((pos+size) < LEN(workstr))
				str2 = CUT(workstr,pos+size,LEN(workstr))
				workstr = str1""repl""str2
			ELSE
				workstr = str1""repl
			END
		END
		pos = pos+LEN(repl)
	END
	RETURN workstr
END
//}}}

//{{{ NewParse
//------------------------------------------
//
//	NewParse
//
//	Function: cut a string into several parts and
//            store each part into a variable.
//            The string is cut before each
//            occurence of a specified character.
//
//	Call: NewParse(string,divider)
//
//	Arguments:
//		string  = characters string
//		divider = character used as a separator
//                between each part of the string
//
//	Return: number of variables created.
//          This function create global variables
//			named var(1), var(2)...var(N), where
//          N is the value returned by the function.
//
//  Note: if the string contained two or more
//        successive separators, no variable is
//        created for these parts of the string.
//        For example, if you call the NewParse
//        function for "First;;Second" with
//        divider=";", only two variables are
//        created (var(1)="First" and
//        var(2)="Second").
//
//------------------------------------------

FUNCTION NewParse(string,divider)
	LOCAL pos i workstr size
	i = 0
	pos = 1
	workstr = string
	
	IF ((CMP(workstr,"") == 0) && (CMP(divider,"") == 0) && (CMP(workstr,divider) == 0))
		WHILE ((pos = Find(workstr,divider,1)) > 0)
			IF ((pos != 1) && (pos != LEN(workstr)))
				i = i+1
				var(i) = CUT(workstr,1,pos-1)
				workstr = CUT(workstr,pos+1,LEN(workstr))
			ELSE
				IF (pos == 1)
					IF (pos != LEN(workstr))
						workstr = CUT(workstr,2,LEN(workstr))
					ELSE
						workstr = ""
					END
				ELSE
					workstr = CUT(workstr,pos,LEN(workstr))
				END
			END
		END
		if (CMP(workstr,0) == 0)
			i = i+1
			var(i) = workstr
		END
	END
	RETURN i
END
//}}}

//{{{ FileRequester(title,path,file,pattern)
//------------------------------------------
//
//	FileRequester
//
//	Function: open a file requester
//
//	Call: FileRequester(title,path,file,pattern)
//
//	Arguments:
//		title   = requester title
//		path    = default directory
//      file    = default filename
//      pattern = default pattern
//
//	Return: 0 if user clicks on Cancel
//          1 if user chooses a file. This
//          function creates three global
//          variables: pathname (path
//          to choosen file), filename
//          (name of choosen file without
//          extension) and extension
//          (extension of choosen file)
//
//------------------------------------------

FUNCTION FileRequester(title,path,file,pattern)
	LOCAL fullname point slash size titre
	
	pathname = ""
	filename = ""
	extension = ""
	
	IF (CMP(pattern,0) == 1)
		titre = "|"
	ELSE
		titre = "|"pattern
	END
	IF (CMP(file,0) == 1)
		titre = "|"titre
	ELSE
		titre = "|"file""titre
	END
	IF (CMP(path,0) == 1)
		titre = "|"titre
	ELSE
		titre = "|"path""titre
	END
	IF (CMP(title,0) == 1)
		titre = "Choose a file"titre
	ELSE
		titre = title""titre
	END

	tv_ReqFile titre
	fullname = Result
	size = LEN(fullname)
	
	IF (CMP(fullname,"Cancel") == 1)
		RETURN 0
	ELSE
		IF ((point = LastPos(fullname,".")) != 0)
			extension = CUT(fullname,point+1,size)
			size = point-1
			fullname = CUT(fullname,1,size)
		END
		IF ((slash = LastPos(fullname,"\")) != 0)
			filename = CUT(fullname,slash+1,size)
			size = slash-1
			pathname = CUT(fullname,1,size)
		END
		RETURN 1
	END
END
//}}}

//}}}**
